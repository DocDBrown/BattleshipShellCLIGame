#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'

# bs_load_state.sh - Library to load and validate saved game files for battleship_shell_script
# Purpose: Provide functions to load a saved game file generated by save_state.sh.
# Usage: Caller should source this file and call bs_load_state_load_file "/path/to/save.sav"
# Environment: Expects checksum.sh, board_state.sh, ship_rules.sh and stats.sh (sourced by caller) to be available.
# Exit codes (returned by bs_load_state_load_file):
# 0 - success
# 1 - invalid usage / arguments
# 2 - file missing / unreadable / security check
# 3 - checksum mismatch or checksum computation error
# 4 - parse/validation error
# 5 - missing dependency
# Security: Do not execute any content from save file. Treat all fields as untrusted; strictly validate types.
# Logging: Uses bs_log_info/bs_log_warn/bs_log_error if available; otherwise writes concise messages to stderr.

_bs_ls_init_logging() {
	:
}

_bs_log_emit() {
	local level="$1"
	shift
	local msg="$1"
	shift || true
	if command -v bs_log_info >/dev/null 2>&1; then
		case "$level" in
		INFO) bs_log_info "$msg" "{}" || true ;;
		WARN) bs_log_warn "$msg" "{}" "" "" || true ;;
		ERROR) bs_log_error "$msg" "{}" "{}" "" || true ;;
		*) bs_log_info "$msg" "{}" || true ;;
		esac
	else
		case "$level" in
		ERROR) printf 'ERROR: %s\n' "$msg" >&2 ;;
		WARN) printf 'WARN: %s\n' "$msg" >&2 ;;
		*) printf 'INFO: %s\n' "$msg" >&2 ;;
		esac
	fi
}

_bs_validate_dep() {
	local fn="$1"
	if ! command -v "$fn" >/dev/null 2>&1; then
		_bs_log_emit ERROR "Missing required dependency: $fn"
		return 1
	fi
	return 0
}

_bs_tempfile() {
	local tmp
	tmp="$(mktemp -t bs_load_state.XXXXXX)" || return 1
	printf '%s' "$tmp"
}

_bs_strip_trailing_checksum_to_tmp() {
	local file="$1"
	local out="$2"
	LC_ALL=C sed '$d' -- "$file" >"$out"
}

_bs_extract_footer_checksum() {
	local file="$1"
	local last
	last="$(awk 'NF{last=$0}END{print last}' "$file")" || last=""
	if [[ -z "$last" ]]; then
		return 1
	fi
	case "$last" in
	CHECKSUM:*) printf '%s' "${last#CHECKSUM: }" ;;
	*) return 1 ;;
	esac
	return 0
}

_bs_parse_kv() {
	local line="$1"
	if [[ "$line" != *"="* ]]; then
		return 1
	fi
	KPV_KEY="${line%%=*}"
	KPV_VAL="${line#*=}"
	KPV_KEY="$(printf '%s' "$KPV_KEY" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
	KPV_VAL="$(printf '%s' "$KPV_VAL" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
	return 0
}

bs_load_state_load_file() {
	if [ "$#" -ne 1 ]; then
		printf 'Usage: bs_load_state_load_file SAVE_FILE\n' >&2
		return 1
	fi
	local save_file="$1"
	if [[ -z "$save_file" ]]; then
		printf 'Empty path\n' >&2
		return 1
	fi
	case "$save_file" in
	-*)
		printf 'Invalid path\n' >&2
		return 1
		;;
	*$'\n'*)
		printf 'Invalid path\n' >&2
		return 1
		;;
	esac
	if [[ ! -e "$save_file" ]]; then
		printf 'File does not exist: %s\n' "$save_file" >&2
		return 2
	fi
	if [[ ! -f "$save_file" || ! -r "$save_file" ]]; then
		printf 'File not readable: %s\n' "$save_file" >&2
		return 2
	fi

	# Validate required dependencies that will be used
	for dep in \
		bs_checksum_verify \
		bs__sanitize_type \
		bs_ship_length \
		bs_total_segments \
		bs_board_new \
		bs_board_set_ship \
		bs_board_set_hit \
		bs_board_set_miss \
		stats_init \
		stats_on_shot; do
		if ! _bs_validate_dep "$dep"; then
			return 5
		fi
	done

	local tmp_content checksum_expected
	tmp_content="$(_bs_tempfile)" || {
		printf 'Failed to create temp file\n' >&2
		return 2
	}
	# Use RETURN trap to ensure cleanup happens when function returns
	trap 'rm -f -- "${tmp_content-}"' RETURN

	# Extract and validate footer checksum first
	checksum_expected="$(_bs_extract_footer_checksum "$save_file")" || {
		printf 'Missing or malformed checksum footer\n' >&2
		return 4
	}
	# Normalize and validate format: expect 64 hex chars for SHA256
	checksum_expected="$(printf '%s' "$checksum_expected" | tr '[:upper:]' '[:lower:]' | tr -d ' \t\r\n')"
	if [[ ! "$checksum_expected" =~ ^[0-9a-f]{64}$ ]]; then
		printf 'Invalid checksum footer format\n' >&2
		return 4
	fi

	if ! _bs_strip_trailing_checksum_to_tmp "$save_file" "$tmp_content"; then
		printf 'Failed to prepare content for checksum\n' >&2
		return 3
	fi

	# Use bs_checksum_verify helper to compute & compare; it provides distinct failure semantics.
	# Run it in an `if` condition so `set -e` does not abort on non-zero.
	if bs_checksum_verify "$checksum_expected" "$tmp_content"; then
		:
	else
		local rc=$?
		if [ "$rc" -eq 1 ]; then
			_bs_log_emit ERROR "Checksum mismatch for $save_file"
		else
			_bs_log_emit ERROR "Checksum verification failed with code $rc for $save_file"
		fi
		return 3
	fi

	# Parse file into sectioned arrays without mutating global state
	local section="HEADER"
	local line
	local save_version=""
	local board_size=10
	declare -a cfg_lines
	declare -a board_lines
	declare -a turns_lines
	declare -a stats_lines

	while IFS= read -r line || [ -n "${line-}" ]; do
		# skip empty/whitespace lines
		if [[ -z "${line//[[:space:]]/}" ]]; then
			continue
		fi
		case "$line" in
		SAVE_VERSION:*)
			# Expect form: SAVE_VERSION: <num>
			save_version="${line#SAVE_VERSION: }"
			save_version="$(printf '%s' "$save_version" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
			continue
			;;
		"[CONFIG]")
			section="CONFIG"
			continue
			;;
		"[BOARD]")
			section="BOARD"
			continue
			;;
		"[TURNS]")
			section="TURNS"
			continue
			;;
		"[STATS]")
			section="STATS"
			continue
			;;
		"[SHIPS]")
			# Treat as a distinct header so it does not pollute BOARD lines.
			section="SHIPS"
			continue
			;;
		CHECKSUM:*) break ;;
		esac
		case "$section" in
		CONFIG) cfg_lines+=("$line") ;;
		BOARD) board_lines+=("$line") ;;
		TURNS) turns_lines+=("$line") ;;
		STATS) stats_lines+=("$line") ;;
		*) : ;; # ignore lines in HEADER / SHIPS or unknown sections
		esac
	done <"$tmp_content"

	# Validate version
	if [[ -z "$save_version" ]]; then
		printf 'Missing SAVE_VERSION header\n' >&2
		return 4
	fi
	if [[ "$save_version" != "1" ]]; then
		printf 'Unsupported save version: %s\n' "$save_version" >&2
		return 4
	fi

	# Validate CONFIG
	if [ "${#cfg_lines[@]}" -gt 0 ]; then
		local kv
		for kv in "${cfg_lines[@]}"; do
			if _bs_parse_kv "$kv"; then
				case "$KPV_KEY" in
				board_size)
					if [[ "$KPV_VAL" =~ ^[0-9]+$ && "$KPV_VAL" -ge 1 ]]; then
						board_size="$KPV_VAL"
					else
						printf 'Invalid board_size in config: %s\n' "$KPV_VAL" >&2
						return 4
					fi
					;;
				*) : ;;
				esac
			else
				printf 'Invalid config line: %s\n' "$kv" >&2
				return 4
			fi
		done
	fi

	# Syntactic validation of BOARD entries and accumulate ship counts
	declare -A ship_counts
	local total_segments=0
	local entry
	for entry in "${board_lines[@]}"; do
		# Expect r,c,state,owner? owner optional depending on state
		IFS=',' read -r r c state owner_rest <<EOF
$entry
EOF
		owner="${owner_rest:-}"
		owner="$(printf '%s' "$owner" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
		if [[ ! "$r" =~ ^[0-9]+$ || ! "$c" =~ ^[0-9]+$ ]]; then
			printf 'Invalid board coordinates: %s\n' "$entry" >&2
			return 4
		fi
		# Validate coordinate ranges (raw coords 0-based allowed from file)
		if [ "$r" -ge "$board_size" ] || [ "$c" -ge "$board_size" ]; then
			printf 'Board coordinate out of range: %s\n' "$entry" >&2
			return 4
		fi
		case "$state" in
		ship)
			if [[ -z "$owner" ]]; then
				printf 'Missing owner for ship at %s,%s\n' "$r" "$c" >&2
				return 4
			fi
			# sanitize owner using ship rules helper
			owner_sanitized=""
			if ! owner_sanitized="$(bs__sanitize_type "$owner")"; then
				printf 'Invalid ship owner name: %s\n' "$owner" >&2
				return 4
			fi
			ship_counts["$owner_sanitized"]=$((${ship_counts["$owner_sanitized"]:-0} + 1))
			total_segments=$((total_segments + 1))
			;;
		hit) ;;
		miss) ;;
		unknown) ;;
		*)
			printf 'Unknown cell state: %s\n' "$state" >&2
			return 4
			;;
		esac
	done

	# Validate ship counts against canonical lengths
	local ship_type
	for ship_type in "${!ship_counts[@]}"; do
		local expected_len
		if ! expected_len="$(bs_ship_length "$ship_type" 2>/dev/null)"; then
			printf 'Unknown ship type in saved board: %s\n' "$ship_type" >&2
			return 4
		fi
		if [[ ! "${ship_counts[$ship_type]}" =~ ^[0-9]+$ ]]; then
			printf 'Invalid segment count for %s\n' "$ship_type" >&2
			return 4
		fi
		if [ "${ship_counts[$ship_type]}" -ne "$expected_len" ]; then
			printf 'Inconsistent segment count for %s: found=%s expected=%s\n' \
				"$ship_type" "${ship_counts[$ship_type]}" "$expected_len" >&2
			return 4
		fi
	done

	# Optionally validate total segments vs canonical total if helper present
	if type bs_total_segments >/dev/null 2>&1; then
		local expected_total
		expected_total="$(bs_total_segments)"
		if [[ "$total_segments" -ne "$expected_total" ]]; then
			printf 'Total ship segments mismatch: found=%s expected=%s\n' \
				"$total_segments" "$expected_total" >&2
			return 4
		fi
	fi

	# Validate turns entries
	for entry in "${turns_lines[@]}"; do
		IFS=',' read -r shooter result <<EOF
$entry
EOF
		shooter="${shooter,,}"
		result="${result,,}"
		if [[ "$shooter" != "player" && "$shooter" != "ai" ]]; then
			printf 'Invalid shooter in turn: %s\n' "$entry" >&2
			return 4
		fi
		if [[ "$result" != "hit" && "$result" != "miss" && "$result" != "sunk" ]]; then
			printf 'Invalid result in turn: %s\n' "$entry" >&2
			return 4
		fi
	done

	# Validate stats lines
	for kv in "${stats_lines[@]}"; do
		if _bs_parse_kv "$kv"; then
			case "$KPV_KEY" in
			start_ts | end_ts)
				if [[ ! "$KPV_VAL" =~ ^[0-9]+$ ]]; then
					printf 'Invalid stats timestamp: %s\n' "$kv" >&2
					return 4
				fi
				;;
			*) : ;;
			esac
		else
			printf 'Invalid stats line: %s\n' "$kv" >&2
			return 4
		fi
	done

	# All validations passed; now apply to in-memory state
	stats_init || true
	if ! bs_board_new "$board_size"; then
		printf 'Failed to initialize board size %s\n' "$board_size" >&2
		return 4
	fi

	# Apply board entries
	for entry in "${board_lines[@]}"; do
		IFS=',' read -r r c state owner_rest <<EOF
$entry
EOF
		owner="${owner_rest:-}"
		owner="$(printf '%s' "$owner" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
		if [[ "$state" == "ship" ]]; then
			if ! bs_board_set_ship "$r" "$c" "$owner"; then
				printf 'Failed to set ship at %s,%s owner=%s\n' "$r" "$c" "$owner" >&2
				return 4
			fi
		elif [[ "$state" == "hit" ]]; then
			if ! bs_board_set_hit "$r" "$c"; then
				printf 'Failed to set hit at %s,%s\n' "$r" "$c" >&2
				return 4
			fi
		elif [[ "$state" == "miss" ]]; then
			if ! bs_board_set_miss "$r" "$c"; then
				printf 'Failed to set miss at %s,%s\n' "$r" "$c" >&2
				return 4
			fi
		fi
	done

	# Apply turns to stats
	for entry in "${turns_lines[@]}"; do
		IFS=',' read -r shooter result <<EOF
$entry
EOF
		shooter="${shooter,,}"
		result="${result,,}"
		if ! stats_on_shot "$shooter" "$result"; then
			printf 'Failed to record shot: %s\n' "$entry" >&2
			return 4
		fi
	done

	# Restore explicit stats timestamps if present
	for kv in "${stats_lines[@]}"; do
		if _bs_parse_kv "$kv"; then
			case "$KPV_KEY" in
			start_ts)
				if declare -p _STATS_START >/dev/null 2>&1; then _STATS_START="$KPV_VAL"; fi
				;;
			end_ts)
				if declare -p _STATS_END >/dev/null 2>&1; then _STATS_END="$KPV_VAL"; fi
				;;
			esac
		fi
	done

	_bs_log_emit INFO "Loaded save file: $save_file"
	return 0
}

export -f bs_load_state_load_file